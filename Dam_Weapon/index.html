<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ダム戦場武器ケースマップ</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; background: #111; }
    .pin-img { width: 240px; height: 160px; object-fit: cover; display: block; border-radius: 8px; }
    .pin-title { font-weight: 600; margin: 0 0 8px; font-size: 14px; }
    .pin-meta { font-size: 12px; color: #e5e7eb; margin-top: 6px; white-space: pre-wrap; line-height: 1.4; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 9999px; background: #f3f4f6; font-size: 11px; margin-left: 6px; }
    .hint { position: fixed; right: 10px; bottom: 10px; background: rgba(17,17,17,.65); color:#fff; padding:6px 8px; border-radius:8px; font-size:12px; z-index: 1000; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="hint">画像が表示されない場合は同フォルダに <code>map.png</code> を置くか、URLに <code>?img=...&pins=...</code> を付けてください。</div>

  <script>
    const map = L.map('map', { crs: L.CRS.Simple, zoomControl: true, minZoom: -3 });
    let imageLayer = null;
    let imgW = 0, imgH = 0;
    const layerGroup = L.layerGroup().addTo(map);
    let items = [];

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight, src });
        img.onerror = (e) => reject(e);
        img.src = src;
      });
    }

    async function setBackgroundImage(src){
      try {
        const { w, h } = await loadImage(src);
        imgW = w; imgH = h;
        const bounds = [[0,0],[h,w]];
        if (imageLayer) map.removeLayer(imageLayer);
        imageLayer = L.imageOverlay(src, bounds, { interactive: true }).addTo(map);
        map.fitBounds(bounds);
      } catch (e) {
        console.warn('画像読み込み失敗:', src, e);
      }
    }

    function getQueryParam(name){
      const p = new URLSearchParams(location.search);
      return p.get(name);
    }

    function applyPinsData(data){
      if (data && Array.isArray(data.items)) items = data.items;
      else if (Array.isArray(data)) items = data;
    }

    async function tryFetchJson(url){
      try { const res = await fetch(url); if (!res.ok) throw 0; return await res.json(); }
      catch { return null; }
    }

    async function autoLoad(){
      const imgParam = getQueryParam('img');
      if (imgParam) await setBackgroundImage(imgParam);
      if (!imgW) {
        const base = location.origin + location.pathname.replace(/[^/]*$/, '');
        await setBackgroundImage(base + 'map.png');
      }

      const pinsParam = getQueryParam('pins');
      if (pinsParam) {
        const data = await tryFetchJson(pinsParam); if (data) applyPinsData(data);
      }
      if (!items.length) {
        const base = location.origin + location.pathname.replace(/[^/]*$/, '');
        const data = await tryFetchJson(base + 'map_pins.json'); if (data) applyPinsData(data);
      }
      render();
    }

    function createMarker(item){
      if (item.image) { const preload = new Image(); preload.src = item.image; }

      const marker = L.marker([item.y, item.x], { draggable: false, title: item.title });
      const html =
        '<div>' +
          '<p class="pin-title">' + escapeHtml(item.title) + (item.category ? ' <span class="badge">' + escapeHtml(item.category) + '</span>' : '') + '</p>' +
          (item.image ? '<img class="pin-img" src="' + item.image + '" alt="' + escapeHtml(item.title) + '" width="240" height="160" />' : '') +
          (item.note ? '<div class="pin-meta">' + formatNote(item.note) + '</div>' : '') +
        '</div>';

      marker.bindPopup(html, { maxWidth: 280, autoPan: true, autoPanPadding: [60, 40], offset: L.point(0, -20) });

      marker.on('mouseover', () => marker.openPopup());
      marker.on('mouseout', () => marker.closePopup());
      return marker;
    }

    function formatNote(text){
      let s = String(text)
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/\n/g, '<br>');
      s = sanitizeHtml(s);
      return s;
    }

    function sanitizeHtml(str) {
      return str
        .replace(/<(?!\/?(b|strong|i|em|br|span)(?=\s|>|\/))/gi, '&lt;')
        .replace(/on\w+="[^"]*"/gi, '')
        .replace(/style="(?![^"]*color\s*:)[^"]*"/gi, '');
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
    }

    function render(){
      layerGroup.clearLayers();
      items.forEach(i => createMarker(i).addTo(layerGroup));
    }

    map.setView([0,0], -1);
    autoLoad();
  </script>
</body>
</html>
